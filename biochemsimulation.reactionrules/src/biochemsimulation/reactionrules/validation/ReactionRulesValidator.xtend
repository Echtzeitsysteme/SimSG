/*
 * generated by Xtext 2.12.0
 */
package biochemsimulation.reactionrules.validation

import biochemsimulation.reactionrules.reactionRules.Agent
import biochemsimulation.reactionrules.reactionRules.Observation
import biochemsimulation.reactionrules.reactionRules.ReactionRulesPackage
import biochemsimulation.reactionrules.reactionRules.Rule
import biochemsimulation.reactionrules.reactionRules.Site
import biochemsimulation.reactionrules.reactionRules.Variable
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import biochemsimulation.reactionrules.reactionRules.Initial
import biochemsimulation.reactionrules.reactionRules.RuleBody
import biochemsimulation.reactionrules.reactionRules.AgentPattern
import biochemsimulation.reactionrules.reactionRules.SitePattern
import java.util.HashSet
import biochemsimulation.reactionrules.reactionRules.IndexedLink
import org.eclipse.emf.ecore.EObject

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ReactionRulesValidator extends AbstractReactionRulesValidator {

	@Check
	def checkAgentIdUnique(Agent agent) {
		val rootElement = EcoreUtil2.getRootContainer(agent)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Agent);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Agent
			if(current.name.equals(agent.name)) {
				c++;
			}
			if(c>1) {
				error('Agent IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkVariableIdUnique(Variable variable) {
		val rootElement = EcoreUtil2.getRootContainer(variable)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Variable);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Variable
			if(current.name.equals(variable.name)) {
				c++;
			}
			if(c>1) {
				error('Variable IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkInitialIdUnique(Initial initial) {
		val rootElement = EcoreUtil2.getRootContainer(initial)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Initial);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Initial
			if(current.name.equals(initial.name)) {
				c++;
			}
			if(c>1) {
				error('Initial IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkObservationIdUnique(Observation observation) {
		val rootElement = EcoreUtil2.getRootContainer(observation)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Observation);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Observation
			if(current.name.equals(observation.name)) {
				c++;
			}
			if(c>1) {
				error('Observation IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkRuleIdUnique(Rule rule) {
		val rootElement = EcoreUtil2.getRootContainer(rule)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Rule);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Rule
			if(current.name.equals(rule.name)) {
				c++;
			}
			if(c>1) {
				error('Rule IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkSiteIdUnique(Agent agent) {
		var candidates = EcoreUtil2.getAllContentsOfType(agent, Site);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Site
			var name = current.name
			
			for(candidate2 : candidates) {
				var current2 = candidate2 as Site
				var name2 = current2.name
				if(name.equals(name2)) {
					c++;
				}
				if(c>1) {
					error('Site IDs within Agents must be unique.', ReactionRulesPackage.Literals.AGENT__SITES)
					c = 1;
				}
			}
			c = 0
			
		}
				
	}
	
	@Check
	def checkStateIdUnique(Site site) {
		var candidates =  EcoreUtil2.getAllContentsOfType(site, biochemsimulation.reactionrules.reactionRules.State);
			var c = 0
			
			for(candidate : candidates) {
				var current = candidate as biochemsimulation.reactionrules.reactionRules.State
				var name = current.name
				
				for(candidate2 : candidates) {
					var current2 = candidate2 as biochemsimulation.reactionrules.reactionRules.State
					var name2 = current2.name
					if(name.equals(name2)) {
						c++;
					}
					if(c>1) {
						error('State IDs within Sites must be unique.', ReactionRulesPackage.Literals.SITE__STATES)
						c = 1;
					}
				}
				c = 0
			
			}
				
	}
	
	@Check
	def checkRuleVariables(RuleBody ruleBody) {
		var op = ruleBody.operator
		var variables = ruleBody.variables.variables
		if(op.equals("<->")) {
			if(variables.size() != 2) {
				error('Bi-Directional rules must have two reaction rate variables.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
			}
		}else {
			if(variables.size() != 1) {
				error('Uni-Directional rules must have one reaction rate variable.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
			}
		}
		for(variable : variables) {
			var value = variable.value.value
			var numValue = Double.valueOf(value)
			if(numValue < 0) {
				error('Uni-Directional rules must have positive reaction rates.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
			}
			if(numValue == 0) {
				warning('Uni-Directional rules with rates equal to 0 will be inactive.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
			}
		}		
	}
	
	@Check
	def checkAgentPatternSites(AgentPattern agentPattern) {
		var candidates = EcoreUtil2.getAllContentsOfType(agentPattern, SitePattern);
		var sites = agentPattern.agent.sites.sites
		var siteSet = new HashSet<Site>(sites.size())
		siteSet.addAll(sites)
		
		for(candidate : candidates) {
			var sp = candidate as SitePattern
			var spSite = sp.site
			if(!siteSet.contains(spSite)) {
				error('This Agent does not have a site with ID='+spSite.name, ReactionRulesPackage.Literals.AGENT_PATTERN__SITE_PATTERNS)
			}
		}
	}
	
	@Check
	def checkIndexedLinkConstraint(IndexedLink indexedLink) {
		var rule = null as Rule
		var eObj = indexedLink.eContainer
		while(!(eObj instanceof Rule) && eObj !== null) {
			eObj = eObj.eContainer
		}
		if(eObj instanceof Rule) {
			rule = eObj
		}
		var candidates = EcoreUtil2.getAllContentsOfType(rule, IndexedLink);
		var c = 1
		val thisNum = Integer.valueOf(indexedLink.state)
		for(cnd : candidates) {
			val candidate = cnd as IndexedLink
			val cNum = Integer.valueOf(candidate.state)
			if(cNum == thisNum && !candidate.equals(indexedLink)) {
				c++
			}
			if(c>2){
				error('This indexed link refers to more than two end-points aka. sites.', ReactionRulesPackage.Literals.INDEXED_LINK__STATE)
			}
		}
		if(c<2) {
			error('This indexed link must refer to exactly two end-points aka. sites.', ReactionRulesPackage.Literals.INDEXED_LINK__STATE)
		}
	}
}
