/*
 * generated by Xtext 2.12.0
 */
package biochemsimulation.reactionrules.validation

import biochemsimulation.reactionrules.reactionRules.Agent
import biochemsimulation.reactionrules.reactionRules.Observation
import biochemsimulation.reactionrules.reactionRules.ReactionRulesPackage
import biochemsimulation.reactionrules.reactionRules.Rule
import biochemsimulation.reactionrules.reactionRules.Site
import biochemsimulation.reactionrules.reactionRules.Variable
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import biochemsimulation.reactionrules.reactionRules.Initial
import biochemsimulation.reactionrules.reactionRules.RuleBody
import biochemsimulation.reactionrules.reactionRules.SitePattern
import java.util.HashSet
import biochemsimulation.reactionrules.reactionRules.BoundLink
import biochemsimulation.reactionrules.reactionRules.NumericFromVariable
import biochemsimulation.reactionrules.reactionRules.NumericFromLiteral
import biochemsimulation.reactionrules.reactionRules.ArithmeticVariable
import biochemsimulation.reactionrules.reactionRules.ArithmeticValue
import biochemsimulation.reactionrules.reactionRules.NumericAssignment
import biochemsimulation.reactionrules.reactionRules.PatternAssignment
import biochemsimulation.reactionrules.reactionRules.Pattern
import biochemsimulation.reactionrules.reactionRules.AssignFromPattern
import biochemsimulation.reactionrules.reactionRules.AssignFromVariable
import biochemsimulation.reactionrules.reactionRules.BoundAnyLink
import biochemsimulation.reactionrules.reactionRules.WhatEver
import biochemsimulation.reactionrules.reactionRules.BoundAnyOfTypeLink
import biochemsimulation.reactionrules.reactionRules.ValidAgentPattern

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ReactionRulesValidator extends AbstractReactionRulesValidator {

	@Check
	def checkAgentIdUnique(Agent agent) {
		val rootElement = EcoreUtil2.getRootContainer(agent)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Agent);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Agent
			if(current.name.equals(agent.name)) {
				c++;
			}
			if(c>1) {
				error('Agent IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkVariableIdUnique(Variable variable) {
		val rootElement = EcoreUtil2.getRootContainer(variable)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Variable);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Variable
			if(current.name.equals(variable.name)) {
				c++;
			}
			if(c>1) {
				error('Variable IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkArithmeticVariableFormat(ArithmeticVariable aVar) {
		if(aVar.value.value.contains(" ")) {
			error('Arithmetic variables may not contain any whitespaces!', null)
			return false
		}
		return true
	}
	
	@Check
	def checkInitialIdUnique(Initial initial) {
		val rootElement = EcoreUtil2.getRootContainer(initial)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Initial);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Initial
			if(current.name.equals(initial.name)) {
				c++;
			}
			if(c>1) {
				error('Initial IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkInitialCountInteger(Initial initial) {
		val countVar = initial.count
		var arithVal = null as ArithmeticValue
		if(countVar instanceof NumericFromVariable) {
			val numVar = countVar as NumericFromVariable
			arithVal = numVar.valueVar.value
			
		}else {
			val numLit = countVar as NumericFromLiteral
			arithVal = numLit.value
		}
		
		if(!arithVal.value.matches("^(\\d)*$")) {
			error('Initial count variable must be of type unsigned integer.', null)
		}else {
			val num = Integer.valueOf(arithVal.value)
			if(num==0) {
				warning('Initial count variables equal to 0 will lead to zero instantiated agents.', null)
			}
		}
				
	}
	
	@Check
	def checkInitialIllegalLinkStates(Initial initial) {
		val pattern = patternFromPatternAssignment(initial.initialPattern)
		for(ap : pattern.agentPatterns) {
			if(ap instanceof ValidAgentPattern) {
				val vap = ap  as ValidAgentPattern
				for(sp : vap.sitePatterns.sitePatterns) {
					val linkState = sp.linkState.linkState
					if(linkState instanceof BoundAnyLink || linkState instanceof WhatEver || linkState instanceof BoundAnyOfTypeLink) {
						error('Illegal initial link state! A pattern may only be instantiated with link states of Type: FreeLink("free"), IndexedLink("INT")', null)
					}
				}
			}
			
		}
	}
	
	def Pattern patternFromPatternAssignment(PatternAssignment pa) {
		if(pa instanceof AssignFromPattern) {
			val afp = pa as AssignFromPattern
			return afp.pattern
		}else {
			val afv = pa as AssignFromVariable
			return afv.patternVar.pattern
		}
	}
	
	@Check
	def checkObservationIdUnique(Observation observation) {
		val rootElement = EcoreUtil2.getRootContainer(observation)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Observation);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Observation
			if(current.name.equals(observation.name)) {
				c++;
			}
			if(c>1) {
				error('Observation IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkRuleIdUnique(Rule rule) {
		val rootElement = EcoreUtil2.getRootContainer(rule)
		var candidates = EcoreUtil2.getAllContentsOfType(rootElement, Rule);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Rule
			if(current.name.equals(rule.name)) {
				c++;
			}
			if(c>1) {
				error('Rule IDs must be unique.', null)
				c = 1;
			}
		}
				
	}
	
	@Check
	def checkSiteIdUnique(Agent agent) {
		var candidates = EcoreUtil2.getAllContentsOfType(agent, Site);
		var c = 0
		for(candidate : candidates) {
			var current = candidate as Site
			var name = current.name
			
			for(candidate2 : candidates) {
				var current2 = candidate2 as Site
				var name2 = current2.name
				if(name.equals(name2)) {
					c++;
				}
				if(c>1) {
					error('Site IDs within Agents must be unique.', ReactionRulesPackage.Literals.AGENT__SITES)
					c = 1;
				}
			}
			c = 0
			
		}
				
	}
	
	@Check
	def checkStateIdUnique(Site site) {
		var candidates =  EcoreUtil2.getAllContentsOfType(site, biochemsimulation.reactionrules.reactionRules.State);
			var c = 0
			
			for(candidate : candidates) {
				var current = candidate as biochemsimulation.reactionrules.reactionRules.State
				var name = current.name
				
				for(candidate2 : candidates) {
					var current2 = candidate2 as biochemsimulation.reactionrules.reactionRules.State
					var name2 = current2.name
					if(name.equals(name2)) {
						c++;
					}
					if(c>1) {
						error('State IDs within Sites must be unique.', ReactionRulesPackage.Literals.SITE__STATES)
						c = 1;
					}
				}
				c = 0
			
			}
				
	}
	
	
	@Check
	def checkRuleVariables(RuleBody ruleBody) {
		var op = ruleBody.operator
		var variables = ruleBody.variables.variables
		if(op.equals("<->")) {
			if(variables.size() != 2) {
				error('Bi-Directional rules must have two reaction rate variables.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
			}
		}else {
			if(variables.size() != 1) {
				error('Uni-Directional rules must have one reaction rate variable.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
			}
		}
		for(variable : variables) {
			var value = valueOfNumericAssignment(variable)
			var faulty = false;
			if(value.contains(" ")) {
				error('Arithmetic variables may not contain any whitespaces!', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
				faulty = true;
			}
			if(!value.matches("^(-)?(\\d)+(\\.)(\\d)+E(-|\\+)(\\d)+$") && !value.matches("^(-)?(\\d)*$") && !value.matches("^(-)?(\\d)+(\\.)(\\d)+$")) {
				error('Given expression does not adhere to any known number format.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
				faulty = true;
			}
			if(!faulty) {
				var numValue = Double.valueOf(value)
				if(numValue < 0) {
					error('Uni-Directional rules must have positive reaction rates.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
				}
				if(numValue == 0) {
					warning('Uni-Directional rules with rates equal to 0 will be inactive.', ReactionRulesPackage.Literals.RULE_BODY__VARIABLES)
				}
			}
			
		}		
	}
	
	@Check
	def checkRuleNumberOfArgs(RuleBody ruleBody) {
		val lhs = patternFromPatternAssignment(ruleBody.lhs)
		val rhs = patternFromPatternAssignment(ruleBody.rhs)
		if(lhs.agentPatterns.size != rhs.agentPatterns.size) {
			error('Number of arguments on the left hand side of the rule, must match number of arguments on the right hand side.', 
				ReactionRulesPackage.Literals.RULE_BODY__LHS
			)
			error('Number of arguments on the right hand side of the rule, must match number of arguments on the left hand side.', 
				ReactionRulesPackage.Literals.RULE_BODY__RHS
			)
		}
	}
	
	def valueOfNumericAssignment(NumericAssignment na){
		var value = "0"
		if(na instanceof NumericFromLiteral) {
			val nl = na as NumericFromLiteral
			value = nl.value.value
		}else {
			val nv = na as NumericFromVariable
			val ae = nv.valueVar.value
			value = ae.value
		}
		return value
	}
	
	@Check
	def checkAgentPatternSites(ValidAgentPattern agentPattern) {
		var candidates = EcoreUtil2.getAllContentsOfType(agentPattern, SitePattern);
		var sites = agentPattern.agent.sites.sites
		var siteSet = new HashSet<Site>(sites.size())
		siteSet.addAll(sites)
		
		for(candidate : candidates) {
			var sp = candidate as SitePattern
			var spSite = sp.site
			if(!siteSet.contains(spSite)) {
				error('This Agent does not have a site with ID='+spSite.name, ReactionRulesPackage.Literals.VALID_AGENT_PATTERN__SITE_PATTERNS)
			}
		}
	}
	
	@Check
	def checkIndexedLinkConstraint(BoundLink boundLink) {
		var pattern = null as Pattern
		var eObj = boundLink.eContainer
		while(!(eObj instanceof Pattern) && eObj !== null) {
			eObj = eObj.eContainer
		}
		if(eObj instanceof Pattern) {
			pattern = eObj
		}
		var candidates = EcoreUtil2.getAllContentsOfType(pattern, BoundLink);
		var c = 1
		val thisNum = Integer.valueOf(boundLink.state)
		for(cnd : candidates) {
			val candidate = cnd as BoundLink
			val cNum = Integer.valueOf(candidate.state)
			if(cNum == thisNum && !candidate.equals(boundLink)) {
				c++
			}
			if(c>2){
				error('This indexed link refers to more than two end-points aka. sites.', ReactionRulesPackage.Literals.BOUND_LINK__STATE)
			}
		}
		if(c<2) {
			error('This indexed link must refer to exactly two end-points aka. sites.', ReactionRulesPackage.Literals.BOUND_LINK__STATE)
		}
	}
	
}
