ModelID NetworkExample

agent Node(*port)
agent Edge(*port){active, inactive, deleted, added}[weight:FLOAT]

init n1 1 {
			N1:Node(port*[1,3,25]),  N2:Node(port*[2,5,8,19]), N3:Node(port*[4,6,10,12]), 
			N4:Node(port*[7,9,14,16]), N5:Node(port*[11,13,18,22,26]), N6:Node(port*[15,17,20,24]),
			N7:Node(port*[21,23]),
	 		E1:Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){active}, 
	 		E4:Edge(port*[7,8]){active}, E5:Edge(port*[9,10]){active}, E6:Edge(port*[11,12]){active}, 
	 		E7:Edge(port*[15,16]){active}, E8:Edge(port*[17,18]){active}, E9:Edge(port*[21,22]){active},
	 		E10:Edge(port*[23,24]){active}, E11:Edge(port*[25,26]){active}, E12:Edge(port*[19,20]){active}, 
	 		E13:Edge(port*[13,14]){active}
}
[
	E1.weight=1, E2.weight=1, E3.weight=3, E4.weight=2, E5.weight=4, E6.weight=5, E7.weight=1,
	E8.weight=3, E9.weight=4, E10.weight=2, E11.weight=12, E12.weight=8, E13.weight=2
]

// Stochastic rules simulating a dynamic environment

rule increaseWeight {E1:Edge()} -> {E1:Edge()} [E1.weight = E1.weight+1] @ [0.025]

rule decreaseWeight {E1:Edge()}[E1.weight > 1] -> {E1:Edge()} [E1.weight = E1.weight-1] @ [0.025]

rule deleteEdgeActive {Edge(){active}} -> {Edge(){deleted}} @ [0.004]

rule deleteEdgeInactive {Edge(){inactive}} -> {Edge(){deleted}} @ [0.004]

var addPattern = {Node(port*[?]), Node(port*[?]), void}

rule addEdge1 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 1] @ [0.0004]
rule addEdge2 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 2] @ [0.0004]
rule addEdge3 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 3] @ [0.0004]
rule addEdge4 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 5] @ [0.0004]
rule addEdge5 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 8] @ [0.0004]

// Rules of the kTC Algorithm

rule a_removeRedundantAdded {Node(port*[1,3]), Node(port*[2,4]), Edge(port*[1,2]){added}, Edge(port*[3,4])} -> 
	{Node(port*[1]), Node(port*[2]), void, Edge(port*[1,2])}
	
rule b_cleadAdded {Edge(){added}} -> {Edge(){inactive}}

rule c_kTC_repairTwo {
	Node(port*[1,6]), Node(port*[2,3]), Node(port*[4,5]),
	Edge(port*[1,2]){inactive}, E2:Edge(port*[3,4]){inactive}, E3:Edge(port*[5,6]){deleted}
}
->
{
	Node(port*[1,6]), Node(port*[2,3]), Node(port*[4,5]),
	Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){deleted}
}

rule d_kTC_repairOne {
	Node(port*[1,6]), Node(port*[2,3]), Node(port*[4,5]),
	Edge(port*[1,2]){inactive}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){deleted}
}
->
{
	Node(port*[1,6]), Node(port*[2,3]), Node(port*[4,5]),
	Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){deleted}
}

rule e_cleanDeleted {Edge(){deleted}} -> {void}

rule f_kTC_powerUp {
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]), E2:Edge(port*[3,4]), E3:Edge(port*[5,6]){inactive}
} [E1.weight + E2.weight > E3.weight]
	-> 
{
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]), E2:Edge(port*[3,4]), E3:Edge(port*[5,6]){active}
}

rule g_kTC_powerDown {
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){active}
} [E1.weight + E2.weight <= E3.weight]
	->
{
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){inactive}
}

obs activeEdges {Edge(){active}}
obs inactiveEdges {Edge(){inactive}}
obs deletedEdges {Edge(){deleted}}
obs addedEdges {Edge(){added}}
obs edges {Edge()}
obs triangles {
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){active}
}[N1.id < N2.id, N2.id < N3.id]

terminate end time=3600000