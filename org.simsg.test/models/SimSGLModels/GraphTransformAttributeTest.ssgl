ModelID GraphTransformAttributeTest

agent Node2(*port)
agent Edge2(*port){active, inactive}[weight:FLOAT]

init n1 1 {Node2(port*[1]), e1:Edge2(port*[1,2]){active}, Node2(port*[2])}[e1.weight=4]
init n2 1 {Node2(port*[1]), e1:Edge2(port*[1,2]){active}, Node2(port*[2])}[e1.weight=3]

rule connectFwd {Node2(port*[1]), Edge2(port*[1,2]){active}, Node2(port*[2,free(Edge2)]), void, Node2(port*[3, free(Edge2)]), Edge2(port*[3]){active}} -> 
{Node2(port*[1]), Edge2(port*[1,2]){active}, Node2(port*[2,4]), Edge2(port*[4,5]){active}, Node2(port*[3, 5]), Edge2(port*[3]){active}}
rule connectBwd {Node2(port*[1]), Edge2(port*[1,2]){active}, Node2(port*[2,4]), Edge2(port*[4,5]){active}, Node2(port*[3, 5]), Edge2(port*[3]){active}} -> 
{Node2(port*[1]), Edge2(port*[1,2]){active}, Node2(port*[2]), void, Node2(port*[3]), Edge2(port*[3]){active}}

// Network Example tests

agent Node(*port)
agent Edge(*port){active, inactive, deleted, added}[weight:FLOAT]

init n3 1 {
			N1:Node(port*[1,3,25]),  N2:Node(port*[2,5,8,19]), N3:Node(port*[4,6,10,12]), 
			N4:Node(port*[7,9,14,16]), N5:Node(port*[11,13,18,22,26]), N6:Node(port*[15,17,20,24]),
			N7:Node(port*[21,23]),
	 		E1:Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){active}, 
	 		E4:Edge(port*[7,8]){active}, E5:Edge(port*[9,10]){active}, E6:Edge(port*[11,12]){active}, 
	 		E7:Edge(port*[15,16]){active}, E8:Edge(port*[17,18]){active}, E9:Edge(port*[21,22]){active},
	 		E10:Edge(port*[23,24]){active}, E11:Edge(port*[25,26]){active}, E12:Edge(port*[19,20]){active}, 
	 		E13:Edge(port*[13,14]){active}
}
[
	E1.weight=1, E2.weight=1, E3.weight=3, E4.weight=2, E5.weight=4, E6.weight=5, E7.weight=1,
	E8.weight=3, E9.weight=4, E10.weight=2, E11.weight=12, E12.weight=8, E13.weight=2
]

obs checkConsistency {
			N1:Node(port*[1,3,25]),  N2:Node(port*[2,5,8,19]), N3:Node(port*[4,6,10,12]), 
			N4:Node(port*[7,9,14,16]), N5:Node(port*[11,13,18,22,26]), N6:Node(port*[15,17,20,24]),
			N7:Node(port*[21,23]),
	 		E1:Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){active}, 
	 		E4:Edge(port*[7,8]){active}, E5:Edge(port*[9,10]){active}, E6:Edge(port*[11,12]){active}, 
	 		E7:Edge(port*[15,16]){active}, E8:Edge(port*[17,18]){active}, E9:Edge(port*[21,22]){active},
	 		E10:Edge(port*[23,24]){active}, E11:Edge(port*[25,26]){active}, E12:Edge(port*[19,20]){active}, 
	 		E13:Edge(port*[13,14]){active}
}
[
	E1.weight=1, E2.weight=1, E3.weight=3, E4.weight=2, E5.weight=4, E6.weight=5, E7.weight=1,
	E8.weight=3, E9.weight=4, E10.weight=2, E11.weight=12, E12.weight=8, E13.weight=2
]



// Stochastic rules simulating a dynamic environment

rule increaseWeight {E1:Edge()} -> {E1:Edge()} [E1.weight = E1.weight+1] @ [0.25]

rule decreaseWeight {E1:Edge()}[E1.weight > 1] -> {E1:Edge()} [E1.weight = E1.weight-1] @ [0.25]

rule deleteEdgeActive {Edge(){active}} -> {Edge(){deleted}} @ [0.04]

rule deleteEdgeInactive {Edge(){inactive}} -> {Edge(){deleted}} @ [0.04]

var addPattern = {Node(port*[?]), Node(port*[?]), void}

rule addEdge1 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 1] @ [0.004]
rule addEdge2 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 2] @ [0.004]
rule addEdge3 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 3] @ [0.004]
rule addEdge4 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 5] @ [0.004]
rule addEdge5 addPattern -> {Node(port*[1]), Node(port*[2]), E1:Edge(port*[1,2]){added}} [E1.weight = 8] @ [0.004]

// Rules of the kTC Algorithm

rule removeRedundandAdded {Node(port*[1,3]), Node(port*[2,4]), Edge(port*[1,2]){added}, Edge(port*[3,4])} -> 
	{Node(port*[1]), Node(port*[2]), void, Edge(port*[1,2])}
	
rule cleadAdded {Edge(){added}} -> {Edge(){inactive}}

rule repairTwo {
	Node(port*[1,6]), Node(port*[2,3]), Node(port*[4,5]),
	Edge(port*[1,2]){inactive}, E2:Edge(port*[3,4]){inactive}, E3:Edge(port*[5,6]){deleted}
}
->
{
	Node(port*[1,6]), Node(port*[2,3]), Node(port*[4,5]),
	Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){deleted}
}

rule repairOne {
	Node(port*[1,6]), Node(port*[2,3]), Node(port*[4,5]),
	Edge(port*[1,2]){inactive}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){deleted}
}
->
{
	Node(port*[1,6]), Node(port*[2,3]), Node(port*[4,5]),
	Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){deleted}
}

rule cleanDeleted {Edge(){deleted}} -> {void}

rule kTC_powerDown {
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){active}
} [E1.weight + E2.weight <= E3.weight]
	-> 
{
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]){active}, E2:Edge(port*[3,4]){active}, E3:Edge(port*[5,6]){inactive}
}

rule kTC_powerUp {
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]), E2:Edge(port*[3,4]), E3:Edge(port*[5,6]){inactive}
} [E1.weight + E2.weight > E3.weight]
	-> 
{
	N1:Node(port*[1,6]), N2:Node(port*[2,3]), N3:Node(port*[4,5]),
	E1:Edge(port*[1,2]), E2:Edge(port*[3,4]), E3:Edge(port*[5,6]){active}
}

// utility rules

rule reactivate {Edge(){inactive}} -> {Edge(){active}}

rule deactivate {Edge(){active}} -> {Edge(){inactive}}

rule revertDelete {Edge(){deleted}} -> {Edge(){inactive}}

rule revertAdd {Edge(){added}} -> {Edge(){inactive}}
